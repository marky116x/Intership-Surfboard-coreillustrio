# Internship Report - Day 10

## Today We Understood How a Computer Understands Humans
Programming languages are for humans, and they are translated by a compiler to machine-level code. Then the computer understands it, and hence the computing process takes place.

## Understanding Symbols, Tokens, and the Compilation Process

 1. Symbols
Symbols serve as the basic building blocks of language, like alphabets do. They include characters such as:

- Alphabets: a–z (lowercase), A–Z (uppercase)  
- Numbers: 0–9  
- Special Characters: @, #, $, %, &, etc.  

In both normal languages and programming languages, symbols combine to form meaningful structures such as words or code statements.

2. Tokens
A collection of symbols.  
Examples:  
- Nouns: Represent objects or data types (e.g., int, string).  
- Pronouns: Refer to previously mentioned objects (in code, these can be variables).  
- Keywords: Reserved words with specific meanings (e.g., if, while).  
- Operators: Symbols that perform actions (e.g., +, -, =).  

A collection of tokens forms expressions and statements, which are essential for writing code.

 3. Expressions, Sentences, and Statements

 Expressions
An expression is a combination of tokens.  
Example: 5 + 3 * 2  
Expressions can be sentences or statements.

Statements
Can be:  
- Declarative: Assigning values (e.g., int x = 5;).  
- Interrogative.  
- Exclamatory.  

 4. A group of expressions can form a paragraph.

## The Compilation Process
The journey from source code to machine-level code involves several stages:

- Tokenizer: Breaks down the code into tokens for analysis.  
- Syntax Analyzer: Checks the grammatical structure of the code to ensure it follows the programming language’s syntax rules.  
- Semantic Checker: Validates the logic and meaning of the code.  
- Code Generator: Converts the validated code into machine-level instructions.  

This systematic process ensures that high-level programming languages can be translated into a form that machines can understand (machine-level code).

## After Computer Compilation, We Spoke About Compounding

### The Power of Compounding
In Skills and Knowledge
Just as interest compounds to grow wealth, skills and knowledge must also be compounded to maximize their impact.  
This involves:  
- Skill Compounding: Continuously building on foundational skills and practicing them frequently.  
- Knowledge Connection: Integrating different fields of knowledge to solve complex problems innovatively.  

Example: Like problem-solving and writing together.  
The ability to connect different areas of expertise improves problem-solving skills and makes one a more effective and versatile person.

---

# Today We Went Deep into JavaScript by Solving Problems
Here’s a look at the key learning and insights gained through problems.

1. Writing and Calling Functions Properly
The first challenge was understanding how to write functions correctly and call them the right way. It seemed straightforward, but I realized that even small mistakes could cause outputs to fail.  
This exercise taught me the importance of correct function syntax and naming.

2. Parameterized Functions and Function Calls
Next was understanding parameterized functions. Instead of calling different variables, we can use parameters to pass in the function for better optimization.

3. Using Ternary Operators for Optimization
Replacing simple if-else conditions with ternary operators made determining if a number is even or odd cleaner and more concise.  
Learning: Writing optimized and neat code. This small change made the code more readable and slightly faster.

4. Summing Arrays: For Loop and .map() Function
Calculating the sum of an array using a for loop was effective, but I also learned that the .map() function was a much simpler and optimized way to write.  
The .map() function was a new concept for me, but it felt necessary to learn. It provided a better way to iterate over arrays.

5. Finding the Largest Number
Inbuilt functions like Math.max were both simple and easier to use—a straightforward approach that saved time and lines of code.

6. Counting Vowels and Using .includes()
For counting vowels in a string, I learned the .includes() method. This simplified searching for specific characters within a string.  
It replaced multiple if-else conditions with a single, more efficient method.

7. Objects
Representing real-world entities as objects in JavaScript and accessing their properties.

8 Score Grading: If-Else vs. Switch Statements
For the score grading problem, I initially used if-else statements, but rewriting it using switch statements made the code cleaner and more optimized for multiple conditions.

## Conclusion
Through these problems, I learned more than just syntax—I learned how to think like a programmer.  
It was about finding different ways to write optimized code and make programs readable.  
Understanding functions, array methods, and the .map() function was particularly valuable.  
I also learnt to write Algorithims for each problems.

This hands-on approach helped me build a stronger foundation in JavaScript, one problem at a time.
